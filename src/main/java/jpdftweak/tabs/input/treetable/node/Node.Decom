package jpdftweak.tabs.input.treetable.node;

import com.esotericsoftware.kryo.Kryo;
import org.jdesktop.swingx.treetable.MutableTreeTableNode;
import java.util.Iterator;
import java.util.Map;
import jpdftweak.tabs.input.treetable.node.userobject.RealFileUserObject;
import jpdftweak.tabs.input.treetable.node.userobject.FolderUserObject;
import jpdftweak.tabs.input.treetable.node.userobject.PageUserObject;
import java.util.TreeMap;
import jpdftweak.tabs.input.treetable.UserObjectValue;
//import jpdftweak.tabs.input.treetable.items.Node;
import jpdftweak.tabs.input.treetable.node.userobject.UserObject;
import jpdftweak.tabs.input.treetable.SwapObserver;
import com.esotericsoftware.kryo.KryoCopyable;
import org.jdesktop.swingx.treetable.AbstractMutableTreeTableNode;

public class Node extends AbstractMutableTreeTableNode implements KryoCopyable<Node> {
	private static SwapObserver observer;
	private String id;
	private UserObject data=null;

	public Node() {
	}

	public Node(final UserObject data) {
		this(data, true);
		this.data=data;
	}

	public Node(final UserObject data, final boolean allowChildren) {
		
				super((Object) data);
		this.allowsChildren = allowChildren;
	}
	

	public static final void setObserver(final SwapObserver observer) {
		Node.observer = observer;
	}

	public static final SwapObserver getObserver() {
		return Node.observer;
	}
	
	 @Override
	    public void setParent(MutableTreeTableNode newParent) {
	        super.setParent(newParent);
	        if(newParent == null)
	            return;
	        this.observer = ((Node)getParent()).getObserver();
	    }

	public UserObject getUserObject() {
		
		return (UserObject) this.userObject;
	}

	public Object getValueAt(final int i) {
		return ((UserObject) this.userObject).getValueAt(i);
	}

	public void setValueAt(final Object aValue, final int column) {
		((UserObject) this.userObject).setValueAt(aValue, column);
	}

	public int getColumnCount() {
		return UserObjectValue.values().length;
	}

	public void sortNode(final int sortColumn, final boolean sortAscending, final boolean recursive) {
		final int childCount = this.getChildCount();
		final TreeMap<Object, Node> nodeData = new TreeMap<Object, Node>();
		for (int i = 0; i < childCount; ++i) {
			final Node child = (Node) this.getChildAt(i);
			if (child.getUserObject() instanceof PageUserObject
					|| child.getUserObject() instanceof RealFileUserObject) {
				return;
			}
			if (child.getChildCount() > 0 && recursive) {
				child.sortNode(sortColumn, sortAscending, recursive);
			}
			final UserObject u = child.getUserObject();
			nodeData.put(u.getKey(), child);
		}
		Iterator<Map.Entry<Object, Node>> nodesIterator;
		if (sortAscending) {
			
			nodesIterator = nodeData.entrySet().iterator();
		} else {
			nodesIterator = (Iterator<Map.Entry<Object, Node>>) nodeData.descendingMap().entrySet().iterator();
		}
		
		int index = 0;
		while (nodesIterator.hasNext()) {
			final Map.Entry<Object, Node> nodeEntry = nodesIterator.next();
			this.swap(nodeEntry.getValue(), index);
			++index;
		}
	}

	private void swap(final Node node, final int index) {
		Node.observer.notify(node, index);
	}

	public Node findChild(final String key) {
		for (final MutableTreeTableNode child : this.children) {
			final Node node = (Node) child;
			if (node.getUserObject().getKey().equals(key)) {
				return node;
			}
		}
		return null;
	}

	public int getFirstLevelChildrenCount() {
		if (!this.allowsChildren) {
			return 0;
		}
		return this.children.size();
	}

	public Node copy(final Kryo kryo) {
		final UserObject uo = (UserObject) kryo.copy(this.userObject);
		final Node n = new Node(uo);
		return n;
	}
}

/*
	DECOMPILATION REPORT

	Decompiled from: C:\Users\E6510\Eclipse-workspace\10B\jpdftweak.zip
	Total time: 93 ms
	
	Decompiled with Procyon 0.5.32.
*/